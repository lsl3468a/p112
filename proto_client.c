/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "proto.h"
#include <stdio.h>
#include <string.h>
#include <unistd.h>

void prompt(char *promptstr, char *buf, int maxsize) {
	printf("[%s] >> ", promptstr);
	fgets(buf, maxsize, stdin);
	buf[strcspn(buf, "\n")] = 0;
}

void printError(int errorCode) {
	switch(errorCode) {
		case AUTHENTICATION_ERROR:
		printf("[-] Error while authenticating (UID mismatch)\n");
		break;
		case DIRECTORY_OPEN_ERROR:
		printf("[-] Error while opening directory (does it exist ?)\n");
		break;
		case DIRECTORY_CLOSE_ERROR:
		printf("[-] Error while closing directory\n");
		break;
		case FILE_OPEN_ERROR:
		printf("[-] Error while opening file (does it exist ?)\n");
		break;
		case FILE_CLOSE_ERROR:
		printf("[-] Error while closing file\n");
		break;
		default:
		printf("[-] Unknown error\n");
	}
}

void listfiles(CLIENT *clnt) {
	ls_res *listResponse;
	liste_nom currentName;
	type_nom dirpath;
	
	dirpath = malloc(MAXNOM);
	prompt("Directory", dirpath, MAXNOM);

	if((listResponse = ls_1(&dirpath, clnt)) == NULL) {
		printf("[-] Error while calling remote procedure\n");
		return;
	}

	if(listResponse->erreur != 0) {
		printError(listResponse->erreur);
		return;
	}

	currentName = listResponse->ls_res_u.liste;

	while(currentName && currentName->suivant) {
		printf("%s\n", currentName->nom);
		currentName = currentName->suivant;
	}

	xdr_free((xdrproc_t) xdr_ls_res, (char *) listResponse);
	xdr_free((xdrproc_t) xdr_type_nom, (char *) &dirpath);
}

void readfile(CLIENT *clnt) {
	read_res *fileContent;
	type_nom filename = malloc(MAXNOM);
	liste_bloc currentBlock;

	prompt("Filename", filename, MAXNOM);
	
	if((fileContent = read_1(&filename, clnt)) == NULL) {
		printf("[-] Error while calling remote procedure\n");
		return;
	}
	
	if(fileContent->erreur != 0) {
		printError(fileContent->erreur);
		return;
	}

	currentBlock = fileContent->read_res_u.fichier;

	while(currentBlock && currentBlock->suivant) {
		printf("%s", currentBlock->bloc);
		currentBlock = currentBlock->suivant;
	}

	printf("\n");

	xdr_free((xdrproc_t) xdr_read_res, (char *) fileContent);
	xdr_free((xdrproc_t) xdr_type_nom, (char *) &filename);

	filename = NULL;
	fileContent = NULL;
}

void writefile(CLIENT *clnt) {
	write_parm params;
	char *intstr;
	liste_bloc currentEntry;
	int *responseCode;

	params.nom = malloc(MAXNOM);
	params.donnees = malloc(sizeof(cell_bloc));
	params.donnees->bloc = malloc(MAXBLOC);
	intstr = malloc(4);

	currentEntry = params.donnees;
	
	prompt("Filename", params.nom, MAXNOM);

	prompt("Erase file", intstr, 4);
	params.ecraser = atoi(intstr);
	
	free(intstr);
	intstr = NULL;
	
	printf("[Content] (Hit CTRL+D when you have finished writing content)\n");

	while(fgets(currentEntry->bloc, MAXBLOC, stdin)) {
		currentEntry->suivant = malloc(sizeof(cell_bloc));
		currentEntry->suivant->bloc = malloc(MAXBLOC);
		currentEntry = currentEntry->suivant;
	}

	currentEntry->suivant = NULL;
	currentEntry = NULL;

	if((responseCode = write_1(&params, clnt)) == NULL) {
		printf("[-] Error while calling remote procedure\n");
		return;
	}

	if(*responseCode != 0) {
		printError(*responseCode);
		return;
	}

	xdr_free((xdrproc_t) xdr_write_parm, (char *) &params);
	xdr_free((xdrproc_t) xdr_int, (char *) responseCode);

	responseCode = NULL;
}

void printhelp() {
	printf("Available commands: \n");
	printf("- ls\t Lists directory content\n");
	printf("- read\t Reads a file\n");
	printf("- write\t Writes content to a file\n");
	printf("- exit\t Exit program\n");
}

void promptCommand(char *host, CLIENT *clnt) {
	char *command = malloc(MAXCOMMAND);
	char *login = malloc(MAXNOM);

	getlogin_r(login, MAXNOM);

	printf("%s@%s$ ", login, host);
	while(fgets(command, MAXCOMMAND, stdin)) {	
		command[strcspn(command, "\n")] = 0;

		if(!strcmp(command, "ls")) {
			listfiles(clnt);
		} else if(!strcmp(command, "read")) {
			readfile(clnt);
		} else if(!strcmp(command, "write")) {
			writefile(clnt);
		} else if(!strcmp(command, "help")) {
			printhelp();
		} else if(!strcmp(command, "exit")) {
			break;
		} else {
			printf("%s: Command not found\n", command);
		}

		printf("%s@%s$ ", login, host);
	}

	free(command);
	command = NULL;
	free(login);
	login = NULL;
}

int main (int argc, char *argv[]) {
	CLIENT *clnt;
	struct timeval delai;
	char *host = malloc(MAXNOM);

	if(argc == 2) {
		strncpy(host, argv[1], MAXNOM);
	} else {
		strncpy(host, "localhost", MAXNOM);
	}

	clnt = clnt_create (host, PROTO_GESTION_FICHIER, PROTO_GESTION_FICHIER_V1, "udp");

	if(clnt == NULL) {
		printf("[-] Can't connect to specified server (it it started ?)\n");
		exit(1);
	}

	// Modification du timeout
	delai.tv_sec = 60;
	delai.tv_usec = 0;
	clnt_control(clnt, CLSET_TIMEOUT, (char *)&delai);
	
	// Sécurisation de l'accès RPC
	clnt->cl_auth = authunix_create_default();

	promptCommand(host, clnt);

	exit (0);
}