/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "proto.h"

#include <dirent.h>
#include <unistd.h>

bool_t authenticate(struct svc_req *rqstp) {
	struct authunix_parms *aup;

	if(rqstp->rq_cred.oa_flavor == AUTH_UNIX) {
		aup = (struct authunix_parms *) rqstp->rq_clntcred;
		if(aup->aup_uid != getuid()) {
			perror("[-] Failed to authenticate client");
			return 0;
		}
	}
	return 1;
}

ls_res *
ls_1_svc(type_nom *dirname, struct svc_req *rqstp)
{
	static ls_res result;
	liste_nom currentName;
	DIR* currentDirectory;
	struct dirent *dir;

	if(!authenticate(rqstp)) {
		result.erreur = AUTHENTICATION_ERROR;
		return &result;
	}
	
	if((currentDirectory = opendir(*dirname)) == NULL) {
		perror("[-] opendir");

		result.erreur = DIRECTORY_OPEN_ERROR;
		return &result;
	}

	printf("[*] Listing directory \"%s\"\n", *dirname);

	result.ls_res_u.liste = malloc(sizeof(cell_nom));
	currentName = result.ls_res_u.liste;

	while(dir = readdir(currentDirectory)) {
		printf("[+] %s\n", dir->d_name);
		currentName->nom = dir->d_name;
		currentName->suivant = malloc(sizeof(cell_nom));
		currentName = currentName->suivant;
	}

	currentName->suivant = NULL;
	currentName = NULL;

	printf("\n");

	if(closedir(currentDirectory) == -1) {
		perror("[-] closedir");

		result.erreur = DIRECTORY_CLOSE_ERROR;
		return &result;
	}

	printf("got\n");

	result.erreur = 0;
	return &result;
}

read_res *
read_1_svc(type_nom *filename, struct svc_req *rqstp)
{
	static read_res result;
	FILE *fd;
	liste_bloc currentEntry;

	if(!authenticate(rqstp)) {
		result.erreur = AUTHENTICATION_ERROR;
		return &result;
	}

	if((fd = fopen(*filename, "r")) == NULL) {
		perror("[-] fopen");

		result.erreur = FILE_OPEN_ERROR;
		return &result;
	}

	result.read_res_u.fichier = malloc(sizeof(cell_bloc));
	result.read_res_u.fichier->bloc = malloc(MAXBLOC);

	currentEntry = result.read_res_u.fichier;

	printf("[*] Serving file content \"%s\":\n", *filename);

	while(fgets(currentEntry->bloc, MAXBLOC, fd) != NULL) {
		printf("%s", currentEntry->bloc);
		currentEntry->suivant = malloc(sizeof(cell_bloc));
		currentEntry->suivant->bloc = malloc(MAXBLOC);
		currentEntry = currentEntry->suivant;
	}

	currentEntry->suivant = NULL;
	currentEntry = NULL;

	if(fclose(fd)) {
		perror("[-] fclose");

		result.erreur = FILE_CLOSE_ERROR;
		return &result;
	}	

	result.erreur = 0;
	return &result;
}

int *
write_1_svc(write_parm *params, struct svc_req *rqstp)
{
	static int result;

	FILE *fd;
	char *mode;
	liste_bloc currentBlock;

	if(!authenticate(rqstp)) {
		result = AUTHENTICATION_ERROR;
		return &result;
	}

	mode = params->ecraser ? "w" : "a";

	if((fd = fopen(params->nom, mode)) == NULL) {
		perror("[-] fopen");

		result = FILE_OPEN_ERROR;
		return &result;
	}

	currentBlock = params->donnees;

	while(currentBlock && currentBlock->suivant) {
		fputs(currentBlock->bloc, fd);
		currentBlock = currentBlock->suivant;
	}

	if(fclose(fd)) {
		perror("[-] fclose");

		result = FILE_CLOSE_ERROR;
		return &result;
	}

	xdr_free((xdrproc_t) xdr_write_parm, (char *) params);

	result = 0;
	return &result;
}
